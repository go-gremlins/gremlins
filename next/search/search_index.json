{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Gremlins \u00b6 Gremlins is a mutation testing tool for Go. It has been made to work well on smallish Go modules, for example microservices , on which it helps validate the test suite, aids the TDD process and can be used as a CI quality gate. As of now, Gremlins doesn't work very well on very big Go modules, mainly because a run can take hours to complete. Warning Gremlins is still in its 0.x.x release, which, as per SemVer, doesn't guarantee backward compatibility. What this means for Gremlins is that configuration flags and/or configuration files can change among minor releases. This may be important if you use Gremlins in automated builds, for example in continuous integration pipelines. Also, while in 0.x.x releases, only the current minor release will be maintained; if we are in v0.2.0, no patch releases will be provided for the v0.1.0 line. Once Gremlins will reach it's 1.x.x release, it will start to be backward compatible, and we'll decide how many releases to maintain at the same time (ex. up to two minors before, as Go itself does). What is Mutation Testing \u00b6 Code coverage is unreliable as a measure of test quality. It is too easy to have tests that exercise a piece of code but don't test anything at all. Mutation testing works by mutating the code exercised by the tests and verifying if the mutation is caught by the test suite. Imagine gremlins going into your code and messing around: will your test suit catch their damage? Features \u00b6 Discovers mutant candidates and tests them Only tests mutants covered by tests Supports five mutant types Yaml-based configuration Can run as quality gate on CI","title":"Home"},{"location":"#welcome-to-gremlins","text":"Gremlins is a mutation testing tool for Go. It has been made to work well on smallish Go modules, for example microservices , on which it helps validate the test suite, aids the TDD process and can be used as a CI quality gate. As of now, Gremlins doesn't work very well on very big Go modules, mainly because a run can take hours to complete. Warning Gremlins is still in its 0.x.x release, which, as per SemVer, doesn't guarantee backward compatibility. What this means for Gremlins is that configuration flags and/or configuration files can change among minor releases. This may be important if you use Gremlins in automated builds, for example in continuous integration pipelines. Also, while in 0.x.x releases, only the current minor release will be maintained; if we are in v0.2.0, no patch releases will be provided for the v0.1.0 line. Once Gremlins will reach it's 1.x.x release, it will start to be backward compatible, and we'll decide how many releases to maintain at the same time (ex. up to two minors before, as Go itself does).","title":"Welcome to Gremlins"},{"location":"#what-is-mutation-testing","text":"Code coverage is unreliable as a measure of test quality. It is too easy to have tests that exercise a piece of code but don't test anything at all. Mutation testing works by mutating the code exercised by the tests and verifying if the mutation is caught by the test suite. Imagine gremlins going into your code and messing around: will your test suit catch their damage?","title":"What is Mutation Testing"},{"location":"#features","text":"Discovers mutant candidates and tests them Only tests mutants covered by tests Supports five mutant types Yaml-based configuration Can run as quality gate on CI","title":"Features"},{"location":"CONTRIBUTING/","text":"Contributing to Gremlins \u00b6 First, thanks for you wanting to contribute, the Gremlins project welcomes contributors! What can I contribute? \u00b6 Report bugs \u00b6 Bug reports are always welcome. Before submitting one, please verify that a similar bug hasn't been already reported. If it already exists, consider to comment there instead of opening a new one. To submit a good bug report \u00b6 Use the appropriate template to submit bugs. Use a clear and descriptive title. Describe each step to reproduce using as much detail as you can. Describe the behaviour you observed after following the steps. Explain why it is different from the behaviour you would expect. Suggest enhancements \u00b6 Before making a feature request/enhancement request, please verify that there isn't already a request for the same or very similar feature. If a similar enhancement request already exists, you can expand on it via comments. There is a specific issue type for feature requests. Send pull requests \u00b6 Pull request are welcome, but it's not guaranteed they will be accepted. We are quite strict on code quality, style and code metrics, bear with us if we ask you to make changes before accepting your PR. Becoming a contributor \u00b6 Gremlins is fully developed on GitHub and the best way to contribute is by forking the repository and, once you complete your work, opening a pull request . Before contributing \u00b6 All contributions are welcome, but, before submitting any significant change, it is better to coordinate with the Gremlins' team before starting the work. It is a good idea to start at the issue tracker and file a new issue or claim an existing one. Open an issue \u00b6 Apart from trivial changes, every contribution to the Gremlins should be linked to an issue. Feel free to propose a change and expose your plans, so that everyone can contribute in its validation, and the chances of your pull request being accepted will increase. Submit a contribution \u00b6 Gremlins is released with semantic versioning and follows GitHub flow , with the only difference that we open release branches when there is a fix version to release. When you open a pull request , a series of automatic checks kicks off. You can verify if your change makes those checks fail and adjust the code accordingly. At this point, a member of the Gremlins team will review your code, possibly will discuss with you to understand it better, maybe ask for some changes and so on. Please expect that this process will be more thorough if you are a first time contributor: we need to know each other. Feel free to make more than one commit in your pull request , but bear in mind that once it has been properly reviewed and accepted, all the commits will be squashed into one before merging. This way we can maintain a linear commit history. Before a release, the code base will be frozen and no pull request will be accepted until the release is done, with the only exception of bug fixes. If you send a pull request during a code freeze, you will have to wait a little more before seeing it merged. Commit messages \u00b6 Commit messages follow a convention. Here is an example: area: do a specific thing Expand on what and how it is done, possibly spanning multiple lines and being descriptive. Fixes #123 First line \u00b6 This is a short one line summary of what has been done in the commit, prefixed by the package affected (ex. mutator , docs , etc.). The commit message should be written as it is answering the question \"This commit changes Gremlins to ...\" The first line is separated from the rest by a blank line. Message body \u00b6 The message body expands on the first line, adding details in a descriptive way. Try to use correct grammar and punctuation, and don't use Markdown, HTML or other markup languages. Reference \u00b6 If the commit is related to an issue (most of the time it does), you can add a reference in the format KEYWORD #ISSUE_NUMBER . This helps GitHub link the commit to the appropriate issue and update its status. The recognized keywords are: close closes closed fix fixes fixed resolve resolves resolved Sometimes the team members as well forget to respect all of these rules, but we do our best to be consistent. If you forget or make mistakes, we will help during the review process.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-to-gremlins","text":"First, thanks for you wanting to contribute, the Gremlins project welcomes contributors!","title":"Contributing to Gremlins"},{"location":"CONTRIBUTING/#what-can-i-contribute","text":"","title":"What can I contribute?"},{"location":"CONTRIBUTING/#report-bugs","text":"Bug reports are always welcome. Before submitting one, please verify that a similar bug hasn't been already reported. If it already exists, consider to comment there instead of opening a new one.","title":"Report bugs"},{"location":"CONTRIBUTING/#to-submit-a-good-bug-report","text":"Use the appropriate template to submit bugs. Use a clear and descriptive title. Describe each step to reproduce using as much detail as you can. Describe the behaviour you observed after following the steps. Explain why it is different from the behaviour you would expect.","title":"To submit a good bug report"},{"location":"CONTRIBUTING/#suggest-enhancements","text":"Before making a feature request/enhancement request, please verify that there isn't already a request for the same or very similar feature. If a similar enhancement request already exists, you can expand on it via comments. There is a specific issue type for feature requests.","title":"Suggest enhancements"},{"location":"CONTRIBUTING/#send-pull-requests","text":"Pull request are welcome, but it's not guaranteed they will be accepted. We are quite strict on code quality, style and code metrics, bear with us if we ask you to make changes before accepting your PR.","title":"Send pull requests"},{"location":"CONTRIBUTING/#becoming-a-contributor","text":"Gremlins is fully developed on GitHub and the best way to contribute is by forking the repository and, once you complete your work, opening a pull request .","title":"Becoming a contributor"},{"location":"CONTRIBUTING/#before-contributing","text":"All contributions are welcome, but, before submitting any significant change, it is better to coordinate with the Gremlins' team before starting the work. It is a good idea to start at the issue tracker and file a new issue or claim an existing one.","title":"Before contributing"},{"location":"CONTRIBUTING/#open-an-issue","text":"Apart from trivial changes, every contribution to the Gremlins should be linked to an issue. Feel free to propose a change and expose your plans, so that everyone can contribute in its validation, and the chances of your pull request being accepted will increase.","title":"Open an issue"},{"location":"CONTRIBUTING/#submit-a-contribution","text":"Gremlins is released with semantic versioning and follows GitHub flow , with the only difference that we open release branches when there is a fix version to release. When you open a pull request , a series of automatic checks kicks off. You can verify if your change makes those checks fail and adjust the code accordingly. At this point, a member of the Gremlins team will review your code, possibly will discuss with you to understand it better, maybe ask for some changes and so on. Please expect that this process will be more thorough if you are a first time contributor: we need to know each other. Feel free to make more than one commit in your pull request , but bear in mind that once it has been properly reviewed and accepted, all the commits will be squashed into one before merging. This way we can maintain a linear commit history. Before a release, the code base will be frozen and no pull request will be accepted until the release is done, with the only exception of bug fixes. If you send a pull request during a code freeze, you will have to wait a little more before seeing it merged.","title":"Submit a contribution"},{"location":"CONTRIBUTING/#commit-messages","text":"Commit messages follow a convention. Here is an example: area: do a specific thing Expand on what and how it is done, possibly spanning multiple lines and being descriptive. Fixes #123","title":"Commit messages"},{"location":"CONTRIBUTING/#first-line","text":"This is a short one line summary of what has been done in the commit, prefixed by the package affected (ex. mutator , docs , etc.). The commit message should be written as it is answering the question \"This commit changes Gremlins to ...\" The first line is separated from the rest by a blank line.","title":"First line"},{"location":"CONTRIBUTING/#message-body","text":"The message body expands on the first line, adding details in a descriptive way. Try to use correct grammar and punctuation, and don't use Markdown, HTML or other markup languages.","title":"Message body"},{"location":"CONTRIBUTING/#reference","text":"If the commit is related to an issue (most of the time it does), you can add a reference in the format KEYWORD #ISSUE_NUMBER . This helps GitHub link the commit to the appropriate issue and update its status. The recognized keywords are: close closes closed fix fixes fixed resolve resolves resolved Sometimes the team members as well forget to respect all of these rules, but we do our best to be consistent. If you forget or make mistakes, we will help during the review process.","title":"Reference"},{"location":"install/","text":"Install \u00b6 Gremlins can be installed via pre-compiled binaries or from source. Pre compiled binaries \u00b6 Linux \u00b6 We don't have public repositories yet. To install, you have to download the package appropriate to your architecture/OS and install it \"manually\". deb rpm Download a .deb file appropriate for your ARCH from the release page , then install with: dpkg -i gremlins_X.Y.Z_linux_amd64.deb Download a .rpm file appropriate for your ARCH from the release page , then install with: rpm -i gremlins_X.Y.Z_linux_amd64.rpm MacOS \u00b6 On macOS, you can use Homebrew . As of now, Gremlins uses only an Homebrew tap . To install, you have to first tap Gremlins' repository: brew tap go-gremlins/tap #(1) Doing this, your tap will refer directly to the Gremlins' tap formula on GitHub. You can delete the tap by \"untapping\" it: brew untap go-gremlins/tap Then you can install it: brew install gremlins Windows \u00b6 As of now, only manual installation is supported. Download the appropriate release package from the release page , extract the zip archive and copy the .exe file somewhere in your execution PATH . Docker \u00b6 You can also run Gremlins using the official Docker image: docker run --rm -v $( pwd ) :/app -w /app gogremlins/gremlins gremlins unleash . Manual install \u00b6 Alternatively, you can download the binary for your OS/ARCH, untar it. For example, on GNU/Linux it could be: tar -xvf gremlins_X.Y.Z_linux_amd64.tar.gz then copy it somewhere in PATH : sudo cp gremlins_X.Y.Z_linux_amd64/gremlins /usr/bin From source \u00b6 Go install \u00b6 Gremlins can be installed with the Go install command. Only the Go compiler is needed. go install github.com/go-gremlins/gremlins/cmd/gremlins@vX.Y.Z Ninja style \u00b6 To build Gremlins you need the Go compiler , make and golangci-lint for linting. You can clone download the source tarball from the release page , then: tar -xvf gremlins-X.Y.Z.tar.gz Ad then: cd gremlins-X.Y.Z make At this point, you can move the generated binary executable to a location of your choice.","title":"Install"},{"location":"install/#install","text":"Gremlins can be installed via pre-compiled binaries or from source.","title":"Install"},{"location":"install/#pre-compiled-binaries","text":"","title":"Pre compiled binaries"},{"location":"install/#linux","text":"We don't have public repositories yet. To install, you have to download the package appropriate to your architecture/OS and install it \"manually\". deb rpm Download a .deb file appropriate for your ARCH from the release page , then install with: dpkg -i gremlins_X.Y.Z_linux_amd64.deb Download a .rpm file appropriate for your ARCH from the release page , then install with: rpm -i gremlins_X.Y.Z_linux_amd64.rpm","title":" Linux"},{"location":"install/#macos","text":"On macOS, you can use Homebrew . As of now, Gremlins uses only an Homebrew tap . To install, you have to first tap Gremlins' repository: brew tap go-gremlins/tap #(1) Doing this, your tap will refer directly to the Gremlins' tap formula on GitHub. You can delete the tap by \"untapping\" it: brew untap go-gremlins/tap Then you can install it: brew install gremlins","title":" MacOS"},{"location":"install/#windows","text":"As of now, only manual installation is supported. Download the appropriate release package from the release page , extract the zip archive and copy the .exe file somewhere in your execution PATH .","title":" Windows"},{"location":"install/#docker","text":"You can also run Gremlins using the official Docker image: docker run --rm -v $( pwd ) :/app -w /app gogremlins/gremlins gremlins unleash .","title":" Docker"},{"location":"install/#manual-install","text":"Alternatively, you can download the binary for your OS/ARCH, untar it. For example, on GNU/Linux it could be: tar -xvf gremlins_X.Y.Z_linux_amd64.tar.gz then copy it somewhere in PATH : sudo cp gremlins_X.Y.Z_linux_amd64/gremlins /usr/bin","title":" Manual install"},{"location":"install/#from-source","text":"","title":"From source"},{"location":"install/#go-install","text":"Gremlins can be installed with the Go install command. Only the Go compiler is needed. go install github.com/go-gremlins/gremlins/cmd/gremlins@vX.Y.Z","title":" Go install"},{"location":"install/#ninja-style","text":"To build Gremlins you need the Go compiler , make and golangci-lint for linting. You can clone download the source tarball from the release page , then: tar -xvf gremlins-X.Y.Z.tar.gz Ad then: cd gremlins-X.Y.Z make At this point, you can move the generated binary executable to a location of your choice.","title":" Ninja style"},{"location":"quick-start/","text":"Quick start \u00b6 To execute a mutation test run, from the root of a Go module execute: $ gremlins unleash #(1) If unleash is too long to type for you, you can use run or r which will do the same. Gremlins only tests mutations of parts of the code already covered by test cases. If a mutant is not covered, why bother testing? You already know it will not be caught. In any case, Gremlins will report which mutations aren't covered. Gremlins will report each mutation as: RUNNABLE : In dry-run mode, a mutation that can be tested. NOT COVERED : A mutation not covered by tests; it will not be tested. KILLED : The mutation has been caught by the test suite. LIVED : The mutation hasn't been caught by the test suite. TIMED OUT : The tests timed out while testing the mutation: the mutation actually made the tests fail, but not explicitly. NOT VIABLE : The mutation makes the build fail.","title":"Quick start"},{"location":"quick-start/#quick-start","text":"To execute a mutation test run, from the root of a Go module execute: $ gremlins unleash #(1) If unleash is too long to type for you, you can use run or r which will do the same. Gremlins only tests mutations of parts of the code already covered by test cases. If a mutant is not covered, why bother testing? You already know it will not be caught. In any case, Gremlins will report which mutations aren't covered. Gremlins will report each mutation as: RUNNABLE : In dry-run mode, a mutation that can be tested. NOT COVERED : A mutation not covered by tests; it will not be tested. KILLED : The mutation has been caught by the test suite. LIVED : The mutation hasn't been caught by the test suite. TIMED OUT : The tests timed out while testing the mutation: the mutation actually made the tests fail, but not explicitly. NOT VIABLE : The mutation makes the build fail.","title":"Quick start"},{"location":"usage/configuration/","text":"Configuration \u00b6 Gremlins can be configured via (in order of precedence): command flags environment variables configuration files Command flags \u00b6 Flags have the higher priority and override all the other means of setting behaviours. Please refer to the specific command documentation to learn how to use them. Configuration files \u00b6 Gremlins can be configured with a configuration file. Location \u00b6 The configuration file can be placed in (in order of precedence) ./.gremlins.yaml (the current directory) The module root /etc/gremlins/.gremlins.yaml $XDG_CONFIG_HOME/gremlins/.gremlins.yaml $HOME/.gremlins.yaml Hint XDG_CONFIG_HOME is usually ~/.config . Override \u00b6 The config file can be overridden with the --config flag. gremlins unleash --config = myConfig.yaml Reference \u00b6 Here is a complete configuration file with all the properties set to their defaults: silent : false unleash : integration : false dry-run : false tags : \"\" output : \"\" threshold : #(1) efficacy : 0 mutant-coverage : 0 mutants : arithmetic-base : enabled : true conditionals-boundary : enabled : true conditionals-negation : enabled : true increment-decrement : enabled : true invert-negatives : enabled : true Thresholds are set by default to 0 , which means they are not enforced. For further information check the specific documentation. Tip You can validate the configuration file using the provided JSON Schema (ex. using it in your editor). The schema can be found at https://gremlins.dev/next/schema/configuration.json . Environment variables \u00b6 Gremlins can be configured via environment variables as well. You can construct the variable name referring to the configuration file format. They start with GREMLINS_ , and each dot and dash becomes an underscore. For example: mutants : arithmetic-base : enabled : true Can be set with: export GREMLINS_MUTANTS_ARITHMETIC_BASE = true","title":"Configuration"},{"location":"usage/configuration/#configuration","text":"Gremlins can be configured via (in order of precedence): command flags environment variables configuration files","title":"Configuration"},{"location":"usage/configuration/#command-flags","text":"Flags have the higher priority and override all the other means of setting behaviours. Please refer to the specific command documentation to learn how to use them.","title":"Command flags"},{"location":"usage/configuration/#configuration-files","text":"Gremlins can be configured with a configuration file.","title":"Configuration files"},{"location":"usage/configuration/#location","text":"The configuration file can be placed in (in order of precedence) ./.gremlins.yaml (the current directory) The module root /etc/gremlins/.gremlins.yaml $XDG_CONFIG_HOME/gremlins/.gremlins.yaml $HOME/.gremlins.yaml Hint XDG_CONFIG_HOME is usually ~/.config .","title":"Location"},{"location":"usage/configuration/#override","text":"The config file can be overridden with the --config flag. gremlins unleash --config = myConfig.yaml","title":"Override"},{"location":"usage/configuration/#reference","text":"Here is a complete configuration file with all the properties set to their defaults: silent : false unleash : integration : false dry-run : false tags : \"\" output : \"\" threshold : #(1) efficacy : 0 mutant-coverage : 0 mutants : arithmetic-base : enabled : true conditionals-boundary : enabled : true conditionals-negation : enabled : true increment-decrement : enabled : true invert-negatives : enabled : true Thresholds are set by default to 0 , which means they are not enforced. For further information check the specific documentation. Tip You can validate the configuration file using the provided JSON Schema (ex. using it in your editor). The schema can be found at https://gremlins.dev/next/schema/configuration.json .","title":"Reference"},{"location":"usage/configuration/#environment-variables","text":"Gremlins can be configured via environment variables as well. You can construct the variable name referring to the configuration file format. They start with GREMLINS_ , and each dot and dash becomes an underscore. For example: mutants : arithmetic-base : enabled : true Can be set with: export GREMLINS_MUTANTS_ARITHMETIC_BASE = true","title":"Environment variables"},{"location":"usage/ci/docker/","text":"Docker \u00b6 Gremlins can be used in CI pipelines using the prebuilt Docker images. As a pipeline step \u00b6 In the continuous integration tool of your choice, you can execute a step using the following syntax: docker run --rm -v $( pwd ) :/app -w /app gogremlins/gremlins:X.Y.Z gremlins unleash . The exact way to specify a runner step in the pipeline script depends on the tool of choice. As a stage in the Dockerfile \u00b6 Gremlins can be also run as a stage in the Dockerfile . FROM gogremlins/gremlins:X.Y.Z AS mutation-testing WORKDIR /my/project/source RUN gremlins unleash For further details, please refer to the Docker multi stage builds documentation .","title":"Docker"},{"location":"usage/ci/docker/#docker","text":"Gremlins can be used in CI pipelines using the prebuilt Docker images.","title":"Docker"},{"location":"usage/ci/docker/#as-a-pipeline-step","text":"In the continuous integration tool of your choice, you can execute a step using the following syntax: docker run --rm -v $( pwd ) :/app -w /app gogremlins/gremlins:X.Y.Z gremlins unleash . The exact way to specify a runner step in the pipeline script depends on the tool of choice.","title":"As a pipeline step"},{"location":"usage/ci/docker/#as-a-stage-in-the-dockerfile","text":"Gremlins can be also run as a stage in the Dockerfile . FROM gogremlins/gremlins:X.Y.Z AS mutation-testing WORKDIR /my/project/source RUN gremlins unleash For further details, please refer to the Docker multi stage builds documentation .","title":"As a stage in the Dockerfile"},{"location":"usage/ci/github-action/","text":"GitHub Action \u00b6 Gremlins can be used in GitHub Actions through the official Run gremlins unleash action . Example usage \u00b6 name : gremlins on : pull_request : push : jobs : gremlins : - uses : actions/checkout@v3 - uses : actions/setup-go@v3 - uses : actions/gremlins-action@v1 with : version : latest args : --tags=\"tag1,tag2\" workdir : test/dir Customization \u00b6 Name Type Default Description version 1 string latest Te version of Gremlins to use args string The command line arguments to pass to gremlins unleash workdir string . Working directory relative to repository root Can be latest , a fixed version like v0.1.2 or a semver range like ~0.2 . In this case this will return v0.2.2 . \u21a9","title":"GitHub Action"},{"location":"usage/ci/github-action/#github-action","text":"Gremlins can be used in GitHub Actions through the official Run gremlins unleash action .","title":"GitHub Action"},{"location":"usage/ci/github-action/#example-usage","text":"name : gremlins on : pull_request : push : jobs : gremlins : - uses : actions/checkout@v3 - uses : actions/setup-go@v3 - uses : actions/gremlins-action@v1 with : version : latest args : --tags=\"tag1,tag2\" workdir : test/dir","title":"Example usage"},{"location":"usage/ci/github-action/#customization","text":"Name Type Default Description version 1 string latest Te version of Gremlins to use args string The command line arguments to pass to gremlins unleash workdir string . Working directory relative to repository root Can be latest , a fixed version like v0.1.2 or a semver range like ~0.2 . In this case this will return v0.2.2 . \u21a9","title":"Customization"},{"location":"usage/commands/","text":"Gremlins \u00b6 The gremlins command works with command and flags. Think of commands as verbs and flags as adjectives. gremlins <command> [ flags ] If you type gremlins a short usage summary will be printed. At any time, you can get further help writing gremlins help <command> Global flags \u00b6 Global flags are not command specific. Config \u00b6 --config \u00b7 Default: empty Overrides the configuration file. gremlins <command> --config = config.yml Silent \u00b6 --silent / -s \u00b7 Default: false Makes Gremlins work in silent mode , which means only errors will be reported on STDOUT. This is useful in CI runs when you don't want to clutter the log, but just read the results from a file or check the exit error code in combination with a threshold configuration. Warning Note that Gremlins will be completely silent if there aren't errors, it doesn't mean it is unresponsive. gremlins <command> --silent","title":"The gremlins command"},{"location":"usage/commands/#gremlins","text":"The gremlins command works with command and flags. Think of commands as verbs and flags as adjectives. gremlins <command> [ flags ] If you type gremlins a short usage summary will be printed. At any time, you can get further help writing gremlins help <command>","title":"Gremlins"},{"location":"usage/commands/#global-flags","text":"Global flags are not command specific.","title":"Global flags"},{"location":"usage/commands/#config","text":"--config \u00b7 Default: empty Overrides the configuration file. gremlins <command> --config = config.yml","title":"Config"},{"location":"usage/commands/#silent","text":"--silent / -s \u00b7 Default: false Makes Gremlins work in silent mode , which means only errors will be reported on STDOUT. This is useful in CI runs when you don't want to clutter the log, but just read the results from a file or check the exit error code in combination with a threshold configuration. Warning Note that Gremlins will be completely silent if there aren't errors, it doesn't mean it is unresponsive. gremlins <command> --silent","title":"Silent"},{"location":"usage/commands/unleash/","text":"Unleash \u00b6 The main command used in Gremlins is unleash , that unleashes the gremlins and starts a mutation test of your code. If unleash is too long to type for you, you can use its aliases run and r . To execute a mutation testing run just type gremlins unleash If the module build requires tags gremlins unleash --tags \"tag1,tag2\" Flags \u00b6 unleash supports several flags to fine tune its behaviour. Integration mode \u00b6 --integration / -i \u00b7 Default: false In normal mode , Gremlins executes only the tests of the packages where the mutant is found. This is done to optimize the performance, running less test cases for each mutation. The drawback of this approach lies in the fact that if a mutation in a package influences the tests of another package, this is not caught by Gremlins. In general, this is an acceptable drawback because packages should rely on their own tests, not on the tests of other packages. Nonetheless, there may be cases where you may want to run all the test suite for each mutation, for example if you are analysing integration or E2E tests. In this scenario, you can enable integration mode . However, you should be aware that integration mode is generally much slower, and you can also get slightly different results depending on your test suite. gremlins unleash --integration Dry run \u00b6 --dry-run / -d \u00b7 Default: false Just performs the analysis but not the mutation testing. gremlins unleash --dry-run Tags \u00b6 --tags / -t \u00b7 Default: empty Sets the go command build tags. gremlins unleash --tags \"tag1,tag2\" Output \u00b6 --output / -o \u00b7 Default: empty When set, Gremlins will write the give output file with machine readable results. gremlins unleash --output = output.json The output file in in JSON format and has the following structure: { \"go_module\" : \"github.com/go-gremlins/gremlins\" , \"test_efficacy\" : 82.00 , //(1) \"mutations_coverage\" : 80.00 , //(2) \"mutants_total\" : 100 , \"mutants_killed\" : 82 , \"mutants_lived\" : 8 , \"mutants_not_viable\" : 2 , //(3) \"mutants_not_covered\" : 10 , \"elapsed_time\" : 123.456 , //(4) \"files\" : [ { \"file_name\" : \"myFile.go\" , \"mutations\" : [ { \"line\" : 10 , \"column\" : 8 , \"type\" : \"CONDITIONALS_NEGATION\" , \"status\" : \"KILLED\" } ] } ] } This is a percentage expressed as floating point number. This is a percentage expressed as floating point number. NOT VIABLE mutants are excluded from all the calculations. The elapsed time is expressed in seconds, expressed as floating point number. Warning The JSON output file is not pretty printed ; it is optimised for machine reading. Threshold efficacy \u00b6 --threshold-efficacy \u00b7 Default: 0 When set, it makes Gremlins exit with an error (code 10) if the test efficacy threshold is not met. By default it is zero, which means Gremlins never exits with an error. The test efficacy is calculated as KILLED / (KILLED + LIVED) and assesses how effective are the tests. gremlins unleash --threshold-efficacy 80 Threshold mutant coverage \u00b6 --threshold-mcover \u00b7 Default: 0 When set, it makes Gremlins exit with an error (code 11) if the mutant coverage threshold is not met. By default it is zero, which means Gremlins never exits with an error. The mutant coverage is calculated as (KILLED + LIVED) / (KILLED + LIVED + NOT_COVERED) and assesses how many mutants are covered by tests. gremlins unleash --threshold-mcover 80 Arithmetic base \u00b6 --arithmetic-base \u00b7 Default: true Enables/disables the ARITHMETIC BASE mutant type. gremlins unleash --arithmetic-base = false Conditionals-boundary \u00b6 --conditionals-boundary \u00b7 Default: true Enables/disables the CONDITIONALS BOUNDARY mutant type. gremlins unleash --conditionals_boundary = false Conditionals negation \u00b6 --conditionals-negation \u00b7 Default: true Enables/disables the CONDITIONALS NEGATION mutant type. gremlins unleash --conditionals_negation = false Increment decrement \u00b6 --increment-decrement \u00b7 Default: true Enables/disables the INCREMENT DECREMENT mutant type. gremlins unleash --increment-decrement = false Invert negatives \u00b6 --invert-negatives \u00b7 Default: true Enables/disables the INVERT NEGATIVES mutant type. gremlins unleash --invert_negatives = false","title":"Unleash"},{"location":"usage/commands/unleash/#unleash","text":"The main command used in Gremlins is unleash , that unleashes the gremlins and starts a mutation test of your code. If unleash is too long to type for you, you can use its aliases run and r . To execute a mutation testing run just type gremlins unleash If the module build requires tags gremlins unleash --tags \"tag1,tag2\"","title":"Unleash"},{"location":"usage/commands/unleash/#flags","text":"unleash supports several flags to fine tune its behaviour.","title":"Flags"},{"location":"usage/commands/unleash/#integration-mode","text":"--integration / -i \u00b7 Default: false In normal mode , Gremlins executes only the tests of the packages where the mutant is found. This is done to optimize the performance, running less test cases for each mutation. The drawback of this approach lies in the fact that if a mutation in a package influences the tests of another package, this is not caught by Gremlins. In general, this is an acceptable drawback because packages should rely on their own tests, not on the tests of other packages. Nonetheless, there may be cases where you may want to run all the test suite for each mutation, for example if you are analysing integration or E2E tests. In this scenario, you can enable integration mode . However, you should be aware that integration mode is generally much slower, and you can also get slightly different results depending on your test suite. gremlins unleash --integration","title":"Integration mode"},{"location":"usage/commands/unleash/#dry-run","text":"--dry-run / -d \u00b7 Default: false Just performs the analysis but not the mutation testing. gremlins unleash --dry-run","title":"Dry run"},{"location":"usage/commands/unleash/#tags","text":"--tags / -t \u00b7 Default: empty Sets the go command build tags. gremlins unleash --tags \"tag1,tag2\"","title":"Tags"},{"location":"usage/commands/unleash/#output","text":"--output / -o \u00b7 Default: empty When set, Gremlins will write the give output file with machine readable results. gremlins unleash --output = output.json The output file in in JSON format and has the following structure: { \"go_module\" : \"github.com/go-gremlins/gremlins\" , \"test_efficacy\" : 82.00 , //(1) \"mutations_coverage\" : 80.00 , //(2) \"mutants_total\" : 100 , \"mutants_killed\" : 82 , \"mutants_lived\" : 8 , \"mutants_not_viable\" : 2 , //(3) \"mutants_not_covered\" : 10 , \"elapsed_time\" : 123.456 , //(4) \"files\" : [ { \"file_name\" : \"myFile.go\" , \"mutations\" : [ { \"line\" : 10 , \"column\" : 8 , \"type\" : \"CONDITIONALS_NEGATION\" , \"status\" : \"KILLED\" } ] } ] } This is a percentage expressed as floating point number. This is a percentage expressed as floating point number. NOT VIABLE mutants are excluded from all the calculations. The elapsed time is expressed in seconds, expressed as floating point number. Warning The JSON output file is not pretty printed ; it is optimised for machine reading.","title":"Output"},{"location":"usage/commands/unleash/#threshold-efficacy","text":"--threshold-efficacy \u00b7 Default: 0 When set, it makes Gremlins exit with an error (code 10) if the test efficacy threshold is not met. By default it is zero, which means Gremlins never exits with an error. The test efficacy is calculated as KILLED / (KILLED + LIVED) and assesses how effective are the tests. gremlins unleash --threshold-efficacy 80","title":"Threshold efficacy"},{"location":"usage/commands/unleash/#threshold-mutant-coverage","text":"--threshold-mcover \u00b7 Default: 0 When set, it makes Gremlins exit with an error (code 11) if the mutant coverage threshold is not met. By default it is zero, which means Gremlins never exits with an error. The mutant coverage is calculated as (KILLED + LIVED) / (KILLED + LIVED + NOT_COVERED) and assesses how many mutants are covered by tests. gremlins unleash --threshold-mcover 80","title":"Threshold mutant coverage"},{"location":"usage/commands/unleash/#arithmetic-base","text":"--arithmetic-base \u00b7 Default: true Enables/disables the ARITHMETIC BASE mutant type. gremlins unleash --arithmetic-base = false","title":"Arithmetic base"},{"location":"usage/commands/unleash/#conditionals-boundary","text":"--conditionals-boundary \u00b7 Default: true Enables/disables the CONDITIONALS BOUNDARY mutant type. gremlins unleash --conditionals_boundary = false","title":"Conditionals-boundary"},{"location":"usage/commands/unleash/#conditionals-negation","text":"--conditionals-negation \u00b7 Default: true Enables/disables the CONDITIONALS NEGATION mutant type. gremlins unleash --conditionals_negation = false","title":"Conditionals negation"},{"location":"usage/commands/unleash/#increment-decrement","text":"--increment-decrement \u00b7 Default: true Enables/disables the INCREMENT DECREMENT mutant type. gremlins unleash --increment-decrement = false","title":"Increment decrement"},{"location":"usage/commands/unleash/#invert-negatives","text":"--invert-negatives \u00b7 Default: true Enables/disables the INVERT NEGATIVES mutant type. gremlins unleash --invert_negatives = false","title":"Invert negatives"},{"location":"usage/mutations/","text":"About Mutations \u00b6 Mutations are the core of Gremlins' activity. Each mutation belongs to a group that defines its flavour . These groups are called mutation types . Gremlins supports various mutation types , each comprising one or more mutations. When Gremlins scans the source code under test, it looks for mutations and for each found mutation creates a mutant . A mutant is the \"gremlin\" that actually changes the source code. Each mutant type can be enabled or disabled, and only a subset of mutations is enabled by default. MutationType Default ARITHMETIC BASE YES CONDITIONALS BOUNDARY YES CONDITIONALS NEGATION YES INCREMENT DECREMENT YES INVERT NEGATIVES YES","title":"Mutations"},{"location":"usage/mutations/#about-mutations","text":"Mutations are the core of Gremlins' activity. Each mutation belongs to a group that defines its flavour . These groups are called mutation types . Gremlins supports various mutation types , each comprising one or more mutations. When Gremlins scans the source code under test, it looks for mutations and for each found mutation creates a mutant . A mutant is the \"gremlin\" that actually changes the source code. Each mutant type can be enabled or disabled, and only a subset of mutations is enabled by default. MutationType Default ARITHMETIC BASE YES CONDITIONALS BOUNDARY YES CONDITIONALS NEGATION YES INCREMENT DECREMENT YES INVERT NEGATIVES YES","title":"About Mutations"},{"location":"usage/mutations/arithmetic_base/","text":"Arithmetic base default \u00b6 Arithmetic base will perform inversions on basic arithmetic operations. Mutation table \u00b6 Original Mutated + - - + * / / * % * Examples \u00b6 Original Mutated a := 1 + 2 a := 1 - 2","title":"Arithmetic base"},{"location":"usage/mutations/arithmetic_base/#arithmetic-base-default","text":"Arithmetic base will perform inversions on basic arithmetic operations.","title":"Arithmetic base  default"},{"location":"usage/mutations/arithmetic_base/#mutation-table","text":"Original Mutated + - - + * / / * % *","title":"Mutation table"},{"location":"usage/mutations/arithmetic_base/#examples","text":"Original Mutated a := 1 + 2 a := 1 - 2","title":"Examples"},{"location":"usage/mutations/conditionals_boundary/","text":"Conditionals boundary default \u00b6 Conditionals boundaries modify the boundary of a conditional, which means that exclusive/inclusive ranges will be inverted. Mutation table \u00b6 Original Mutated > >= >= > < <= <= < Examples \u00b6 Original Mutated if a > b { // Do something } if a >= b { // Do something }","title":"Conditionals boundary"},{"location":"usage/mutations/conditionals_boundary/#conditionals-boundary-default","text":"Conditionals boundaries modify the boundary of a conditional, which means that exclusive/inclusive ranges will be inverted.","title":"Conditionals boundary  default"},{"location":"usage/mutations/conditionals_boundary/#mutation-table","text":"Original Mutated > >= >= > < <= <= <","title":"Mutation table"},{"location":"usage/mutations/conditionals_boundary/#examples","text":"Original Mutated if a > b { // Do something } if a >= b { // Do something }","title":"Examples"},{"location":"usage/mutations/conditionals_negation/","text":"Conditionals negation default \u00b6 Conditionals negation inverts the conditional direction, which means a == will become a != . Mutation table \u00b6 Original Mutated == != != == > \\<= <= > < >= >= < Examples \u00b6 Original Mutated if a == b { // Do something } if a != b { // Do something }","title":"Conditionals negation"},{"location":"usage/mutations/conditionals_negation/#conditionals-negation-default","text":"Conditionals negation inverts the conditional direction, which means a == will become a != .","title":"Conditionals negation  default"},{"location":"usage/mutations/conditionals_negation/#mutation-table","text":"Original Mutated == != != == > \\<= <= > < >= >= <","title":"Mutation table"},{"location":"usage/mutations/conditionals_negation/#examples","text":"Original Mutated if a == b { // Do something } if a != b { // Do something }","title":"Examples"},{"location":"usage/mutations/increment_decrement/","text":"Increment decrement default \u00b6 Increment decrement will invert the sign of the increment or decrement. Mutation table \u00b6 Original Mutated ++ -- -- ++ Examples \u00b6 Original Mutated for i := 0 ; i < 10 ; i ++ { // Do something } for i := 0 ; i < 10 ; i -- { // Do something }","title":"Increment decrement"},{"location":"usage/mutations/increment_decrement/#increment-decrement-default","text":"Increment decrement will invert the sign of the increment or decrement.","title":"Increment decrement  default"},{"location":"usage/mutations/increment_decrement/#mutation-table","text":"Original Mutated ++ -- -- ++","title":"Mutation table"},{"location":"usage/mutations/increment_decrement/#examples","text":"Original Mutated for i := 0 ; i < 10 ; i ++ { // Do something } for i := 0 ; i < 10 ; i -- { // Do something }","title":"Examples"},{"location":"usage/mutations/invert_negatives/","text":"Invert negatives default \u00b6 Invert negatives will invert the sign of negative numbers, making them positive. Mutation table \u00b6 Original Mutated - + Examples \u00b6 Original Mutated func makeNegative ( i int ) int { return - i } func makeNegative ( i int ) int { return + i }","title":"Invert negatives"},{"location":"usage/mutations/invert_negatives/#invert-negatives-default","text":"Invert negatives will invert the sign of negative numbers, making them positive.","title":"Invert negatives   default"},{"location":"usage/mutations/invert_negatives/#mutation-table","text":"Original Mutated - +","title":"Mutation table"},{"location":"usage/mutations/invert_negatives/#examples","text":"Original Mutated func makeNegative ( i int ) int { return - i } func makeNegative ( i int ) int { return + i }","title":"Examples"}]}